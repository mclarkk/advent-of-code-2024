Part 1 solution is a simple iterative linear time solution.

I have not yet attempted Part 2 because my goal for this year's AoC is to practice many different kinds of basic Rust data structures and data processing patterns, and Part 2 is more focused on the tricky algorithm. However, at a high level, it looks like it takes advantage of the recursive definition of a safe record. Intuitively it seems like at a point where in Part 1 we would have deemed a particular record as not safe, instead we take a look at two possible options -- what if we removed the current level, or what if we removed the previous level? However, perhaps that is getting too clever...I could see myself getting tripped up on the details. At worst, you could implement a naive version that does this problem in n^2 time, simply by checking every version of the record with each individual level removed. You could improve the n^2 compute by using a dynamic programming approach with memoization that skips a lot of duplicated compute by remembering whether particular subsequences are safe if we've already checked them before.

Anyway, it would be fun to do Part 2, but it looks a little fussy. I have a lot of other AoC problems to catch up on, and I'm trying to optimize for coding diversity rather than algorithmic difficulty. I may come back to this later.